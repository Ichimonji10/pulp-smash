# coding=utf-8
"""Test updateinfo XML generated by yum distributor."""
import unittest
from urllib.parse import urljoin
from xml.etree import ElementTree

from packaging.version import Version
from requests.exceptions import HTTPError

from pulp_smash import api, config, selectors, utils
from pulp_smash.constants import (
    ORPHANS_PATH,
    REPOSITORY_PATH,
    RPM,
    RPM_ERRATUM_ID,
    RPM_ERRATUM_RPM_NAME,
    RPM_NAMESPACES,
    RPM_PKGLISTS_UPDATEINFO_FEED_URL,
    RPM_SIGNED_FEED_URL,
    RPM_UNSIGNED_FEED_URL,
    RPM_UNSIGNED_URL,
)
from pulp_smash.tests.rpm.api_v2.utils import (
    gen_distributor,
    gen_repo,
    get_repodata,
    get_repodata_repomd_xml,
)
from pulp_smash.tests.rpm.utils import (
    check_issue_2277,
    check_issue_2620,
    set_up_module,
)


def setUpModule():  # pylint:disable=invalid-name
    """Possibly skip the tests in this module.

    Skip tests if `Pulp #2277 <https://pulp.plan.io/issues/2277>`_ affects us.
    """
    set_up_module()
    cfg = config.get_config()
    if cfg.version < Version('2.11') and check_issue_2277(cfg):
        raise unittest.SkipTest('https://pulp.plan.io/issues/2277')


def _gen_errata():
    """Generate and return a typical erratum with a unique ID."""
    return {
        'id': utils.uuid4(),
        'description': (
            'This sample description contains some non-ASCII characters '
            ', such as: 汉堡™, and also contains a long line which some '
            'systems may be tempted to wrap.  It will be tested to see '
            'if the string survives a round-trip through the API and '
            'back out of the yum distributor as XML without any '
            'modification.'
        ),
        'issued': '2015-03-05 05:42:53 UTC',
        'pkglist': [{
            'name': 'pkglist-name',
            # This package is present in Pulp Fixtures.
            'packages': [{
                'arch': 'noarch',
                'epoch': '0',
                'filename': 'bear-4.1-1.noarch.rpm',
                'name': 'bear',
                'release': '1',
                'sum': [
                    'sha256',
                    ('ceb0f0bb58be244393cc565e8ee5ef0ad36884d8ba8eec74542ff47'
                     'd299a34c1')
                ],
                'version': '4.1',
            }],
        }],
        'references': [{
            'href': 'https://example.com/errata/PULP-2017-1234.html',
            'id': 'PULP-2017:1234',
            'title': 'PULP-2017:1234',
            'type': 'self'
        }],
        'solution': 'sample solution',
        'status': 'final',
        'title': 'sample title',
        'type': 'pulp',
        'version': '6',  # intentionally string, not int
    }


def _get_updates_by_id(update_info_tree):
    """Return each "update" element in ``update_info_tree``, keyed by ID.

    :param update_info_tree: An ``Element``.
    :returns: A dict in the form ``{id, update_element}``.
    """
    return {
        update.findall('id')[0].text: update
        for update in update_info_tree.findall('update')
    }


class UpdateInfoTestCase(utils.BaseAPITestCase):
    """Tests to ensure ``updateinfo.xml`` can be created and is valid."""

    @classmethod
    def setUpClass(cls):
        """Create, populate and publish a repository.

        More specifically, do the following:

        1. Create an RPM repository with a distributor.
        2. Populate the repository with an RPM and two errata, where one
           erratum references the RPM, and the other does not.
        3. Publish the repository Fetch and parse its ``updateinfo.xml`` file.
        """
        super(UpdateInfoTestCase, cls).setUpClass()
        cls.errata = {key: _gen_errata() for key in ('full', 'partial')}
        del cls.errata['partial']['pkglist']
        cls.tasks = {}

        # Create a repo.
        client = api.Client(cls.cfg, api.json_handler)
        body = gen_repo()
        body['distributors'] = [gen_distributor()]
        repo = client.post(REPOSITORY_PATH, body)
        cls.resources.add(repo['_href'])

        try:
            # Populate and publish the repo.
            repo = client.get(repo['_href'], params={'details': True})
            unit = utils.http_get(RPM_UNSIGNED_URL)
            utils.upload_import_unit(
                cls.cfg, unit, {'unit_type_id': 'rpm'}, repo
            )
            for key, erratum in cls.errata.items():
                report = utils.upload_import_erratum(
                    cls.cfg, erratum, repo['_href']
                )
                cls.tasks[key] = tuple(api.poll_spawned_tasks(cls.cfg, report))
            utils.publish_repo(cls.cfg, repo)

            # Fetch and parse updateinfo.xml.
            cls.updates_element = (
                get_repodata(cls.cfg, repo['distributors'][0], 'updateinfo')
            )
        except:
            cls.tearDownClass()
            raise

    def test_root(self):
        """Assert the root element of the tree has a tag of "updates"."""
        self.assertEqual(self.updates_element.tag, 'updates')

    def test_len_updates(self):
        """Assert there is one "update" element in ``updateinfo.xml``."""
        update_elements = self.updates_element.findall('update')
        self.assertEqual(len(update_elements), 1, update_elements)

    def test_one_id_per_update(self):
        """Assert each "update" element has one "id" child element."""
        for update_element in self.updates_element.findall('update'):
            with self.subTest(update_element=update_element):
                self.assertEqual(len(update_element.findall('id')), 1)

    def test_update_ids_unique(self):
        """Assert each update ID is unique.

        Each "update" element has an "id" child element. These IDs should be
        unique.
        """
        ids = set()
        for update_element in self.updates_element.findall('update'):
            with self.subTest(update_element=update_element):
                id_ = update_element.find('id').text
                self.assertNotIn(id_, ids)
                ids.add(id_)

    def test_one_task_per_import(self):
        """Assert only one task is spawned per erratum upload."""
        for key, tasks in self.tasks.items():
            with self.subTest(key=key):
                self.assertEqual(len(tasks), 1)

    def test_tasks_state(self):
        """Assert each task's state is "finished".

        This test assumes :meth:`test_one_task_per_import` passes.
        """
        for key, tasks in self.tasks.items():
            with self.subTest(key=key):
                self.assertEqual(tasks[0]['state'], 'finished')

    def test_tasks_result(self):
        """Assert each task's result success flag (if present) is true.

        This test assumes :meth:`test_one_task_per_import` passes.
        """
        for key, tasks in self.tasks.items():
            with self.subTest(key=key):
                if 'result' not in tasks[0]:
                    continue
                result = tasks[0]['result']
                self.assertTrue(result['success_flag'], result)

    def test_erratum_description(self):
        """Assert the update info tree has a correct erratum description.

        This test case uploads an erratum that has an interesting description
        with non-ASCII characters, long lines, etc. The erratum description is
        later made available in the update info tree. Verify the description is
        unchanged.
        """
        erratum = self.errata['full']
        update_element = (
            _get_updates_by_id(self.updates_element)[erratum['id']]
        )
        description_elements = update_element.findall('description')
        self.assertEqual(len(description_elements), 1, description_elements)
        self.assertEqual(description_elements[0].text, erratum['description'])

    def test_reboot_not_suggested(self):
        """Assert the update info tree does not suggest a spurious reboot.

        The errata uploaded by this test case do not suggest that a reboot be
        applied. As a result, the relevant ``<update>`` element in the
        ``updateinfo.xml`` file should not have a ``<reboot_suggested>`` tag.
        Verify that this is so. See `Pulp #2032`_.

        .. NOTE:: In previous versions of Pulp, if no reboot should be applied,
            a ``<reboot_suggested>False</reboot_suggested>`` element would be
            present. See `Pulp #1782`_.

        .. _Pulp #1782: https://pulp.plan.io/issues/1782
        .. _Pulp #2032: https://pulp.plan.io/issues/2032
        """
        if selectors.bug_is_untestable(2032, self.cfg.version):
            self.skipTest('https://pulp.plan.io/issues/2032')
        erratum_id = self.errata['full']['id']
        update_element = _get_updates_by_id(self.updates_element)[erratum_id]
        reboot_elements = update_element.findall('reboot_suggested')
        self.assertEqual(
            len(reboot_elements),
            0,
            [ElementTree.tostring(elem) for elem in reboot_elements],
        )


class UpdateRepoTestCase(utils.BaseAPITestCase):
    """Verify ``updateinfo.xml`` changes as the its repo changes."""

    @classmethod
    def setUpClass(cls):
        """Create an RPM repository with a feed and distributor."""
        super().setUpClass()
        client = api.Client(cls.cfg, api.json_handler)
        body = gen_repo()
        body['importer_config']['feed'] = RPM_SIGNED_FEED_URL
        body['distributors'] = [gen_distributor()]
        try:
            repo = client.post(REPOSITORY_PATH, body)
            cls.resources.add(repo['_href'])
            cls.repo = client.get(repo['_href'], params={'details': True})
        except:
            cls.tearDownClass()
            raise

    def test_01_sync_publish(self):
        """Sync and publish the repository.

        Fetch ``updateinfo.xml`` and verify that:

        * an erratum with id :data:`pulp_smash.constants.RPM_ERRATUM_ID` is
          present,
        * the erratum has one "pkglist" child element, and
        * the "pkglist" element has at least the following child elements:

          .. code-block:: xml

            <collection short="">
                <name>1</name>
            </collection>
        """
        utils.sync_repo(self.cfg, self.repo['_href'])
        utils.publish_repo(self.cfg, self.repo)
        updates_element = (
            get_repodata(self.cfg, self.repo['distributors'][0], 'updateinfo')
        )
        update_elements = _get_updates_by_id(updates_element)
        self.assertIn(RPM_ERRATUM_ID, update_elements)

        debug = ElementTree.tostring(update_elements[RPM_ERRATUM_ID])
        pkglist_elements = update_elements[RPM_ERRATUM_ID].findall('pkglist')
        self.assertEqual(len(pkglist_elements), 1, debug)

        debug = ElementTree.tostring(pkglist_elements[0])
        name_elements = (
            pkglist_elements[0].findall('collection[@short=""]/name')
        )
        self.assertEqual(len(name_elements), 1, debug)
        name_element = name_elements[0]
        with self.subTest(comment='assert <name> has no children'):
            self.assertEqual(len(name_element.getchildren()), 0, debug)
        with self.subTest(comment="assert <name>'s text is correct"):
            self.assertEqual(name_element.text, '1', debug)

    def test_02_unassociate_publish(self):
        """Unassociate a content unit and publish the repository.

        Fetch ``updateinfo.xml``. Verify that an erratum with id
        :data:`pulp_smash.constants.RPM_ERRATUM_ID` is not present.
        """
        client = api.Client(self.cfg, api.json_handler)
        client.post(urljoin(self.repo['_href'], 'actions/unassociate/'), {
            'criteria': {'filters': {'unit': {'name': RPM_ERRATUM_RPM_NAME}}}
        })
        utils.publish_repo(self.cfg, self.repo)
        updates_element = (
            get_repodata(self.cfg, self.repo['distributors'][0], 'updateinfo')
        )
        update_elements = _get_updates_by_id(updates_element)
        self.assertNotIn(RPM_ERRATUM_ID, update_elements)


class PkglistsTestCase(unittest.TestCase):
    """Sync a repository whose updateinfo file has multiple pkglist sections.

    This test case targets `Pulp #2227 <https://pulp.plan.io/issues/2227>`_.
    """

    def test_all(self):
        """Sync a repo whose updateinfo file has multiple pkglist sections.

        Do the following:

        1. Create and sync a repository with an importer and distributor.
           Ensure the importer's feed is set to
           :data:`pulp_smash.constants.RPM_PKGLISTS_UPDATEINFO_FEED_URL`.
        2. Publish the repository, and fetch and parse its updateinfo file.
        3. Verify the updateinfo contains the correct number of ``<pkglists>``
           sections, with the correct contents in each.
        """
        cfg = config.get_config()
        if selectors.bug_is_untestable(2227, cfg.version):
            self.skipTest('https://pulp.plan.io/issues/2277')

        # Create and sync a repository.
        client = api.Client(cfg, api.json_handler)
        body = gen_repo()
        body['importer_config']['feed'] = RPM_PKGLISTS_UPDATEINFO_FEED_URL
        body['distributors'] = [gen_distributor()]
        repo = client.post(REPOSITORY_PATH, body)
        repo = client.get(repo['_href'], params={'details': True})
        self.addCleanup(client.delete, repo['_href'])
        utils.sync_repo(cfg, repo['_href'])

        # Publish the repository, and fetch and parse its updateinfo file.
        self.assertEqual(len(repo['distributors']), 1, repo['distributors'])
        utils.publish_repo(cfg, repo)
        root_element = get_repodata(cfg, repo['distributors'][0], 'updateinfo')

        # Verify the contents of the updateinfo file.
        debug = ElementTree.tostring(root_element)
        pkglists = root_element.find('update').findall('pkglist')
        self.assertEqual(len(pkglists), 3, debug)

        collections = [pkglist.find('collection') for pkglist in pkglists]
        names = {collection.find('name').text for collection in collections}
        self.assertEqual(names, {'1', '2', '3'}, debug)

        packages = {
            collection.find('package').find('filename').text
            for collection in collections
        }
        self.assertEqual(packages, {
            'penguin-0.9.1-1.noarch.rpm',
            'shark-0.1-1.noarch.rpm',
            'walrus-5.21-1.noarch.rpm',
        }, debug)


class CleanUpTestCase(unittest.TestCase):
    """Test whether old ``updateinfo.xml`` files are cleaned up.

    Do the following:

    1. Create, populate and publish a repository. Verify that an
       ``updateinfo.xml`` file is present and can be downloaded.
    2. Add an additional content unit to the repository, and publish it again.
       Verify that the ``updateinfo.xml`` file created by the first publish is
       no longer available, and that a new ``updateinfo.xml`` file is
       available.

    This procedure targets `Pulp #2096 <https://pulp.plan.io/issues/2096>`_.
    Note that the second publish must be an incremental publish.
    """

    @classmethod
    def setUpClass(cls):
        """Create and sync a repository."""
        cls.cfg = config.get_config()
        if check_issue_2620(cls.cfg):
            raise unittest.SkipTest('https://pulp.plan.io/issues/2620')
        client = api.Client(cls.cfg, api.json_handler)
        body = gen_repo()
        body['distributors'] = [gen_distributor()]
        body['importer_config']['feed'] = RPM_UNSIGNED_FEED_URL
        cls.repo = client.post(REPOSITORY_PATH, body)
        try:
            cls.repo = client.get(cls.repo['_href'], params={'details': True})
        except:
            cls.tearDownClass()
            raise
        cls.updateinfo_xml_hrefs = []

    @classmethod
    def tearDownClass(cls):
        """Remove the created repository and any orphans."""
        client = api.Client(cls.cfg)
        client.delete(cls.repo['_href'])
        client.delete(ORPHANS_PATH)

    def test_01_first_publish(self):
        """Populate and publish the repository."""
        utils.sync_repo(self.cfg, self.repo['_href'])
        client = api.Client(self.cfg)
        client.post(urljoin(self.repo['_href'], 'actions/unassociate/'), {
            'criteria': {
                'filters': {'unit': {'filename': RPM}},
                'type_ids': ('rpm',),
            }
        })
        utils.publish_repo(self.cfg, self.repo)
        self.updateinfo_xml_hrefs.append(self.get_updateinfo_xml_href())

        with self.subTest(comment='check number of RPMs in repo'):
            units = (
                utils.search_units(self.cfg, self.repo, {'type_ids': ('rpm',)})
            )
            self.assertEqual(len(units), 31)
        with self.subTest(comment='check updateinfo.xml is available'):
            client.get(self.updateinfo_xml_hrefs[0])

    def test_02_second_publish(self):
        """Add an additional content unit and publish the repository again."""
        utils.sync_repo(self.cfg, self.repo['_href'])
        utils.publish_repo(self.cfg, self.repo)
        self.updateinfo_xml_hrefs.append(self.get_updateinfo_xml_href())

        client = api.Client(self.cfg)
        with self.subTest(comment='check number of RPMs in repo'):
            units = (
                utils.search_units(self.cfg, self.repo, {'type_ids': ('rpm',)})
            )
            self.assertEqual(len(units), 32)
        with self.subTest(comment='check updateinfo.xml has a new path'):
            # pylint:disable=no-value-for-parameter
            self.assertNotEqual(*self.updateinfo_xml_hrefs)
        with self.subTest(comment='check old updateinfo.xml is unavailable'):
            with self.assertRaises(HTTPError):
                client.get(self.updateinfo_xml_hrefs[0])
        with self.subTest(comment='check new updateinfo.xml is available'):
            client.get(self.updateinfo_xml_hrefs[1])

    def get_updateinfo_xml_href(self):
        """Return the path to the ``updateinfo.xml`` file."""
        # Download and search through ``.../repodata/repomd.xml``.
        distributor = self.repo['distributors'][0]
        repomd_xml = get_repodata_repomd_xml(self.cfg, distributor)
        xpath = (
            "{{{namespace}}}data[@type='updateinfo']/{{{namespace}}}location"
            .format(namespace=RPM_NAMESPACES['metadata/repo'])
        )
        location_elements = repomd_xml.findall(xpath)

        # Build the URL to the updateinfo.xml file.
        path = urljoin('/pulp/repos/', distributor['config']['relative_url'])
        if not path.endswith('/'):
            path += '/'
        path = urljoin(path, location_elements[0].get('href'))
        return path
